
# Try to guess the local env

# Try to guess our running env (chroot, jail, VM...)
typeset PRDVTY_RUNENV=""

# Check if /proc is available
if [ -e /proc/self/mountinfo ]; then

	# If we have lxc in a cgroup, or if pid1 is spawned by lxc-start
	if grep "/lxc/" /proc/self/cgroup >/dev/null 2>&1 || \
	   grep "container=lxc" /proc/{self,1}/environ >/dev/null 2>&1; then
		MYS_RUNENV="lxc"
	# Same with docker
	elif grep "/docker/" /proc/self/cgroup >/dev/null 2>&1; then
		MYS_RUNENV="docker"
	# If our / is not the real /, we're in a subdir of a shared FS in the parent host
	elif [ "$(awk '$5=="/"{print $4}' /proc/self/mountinfo)" != "/" ]; then
		MYS_RUNENV="chroot"
	fi
# No /proc/self/mountinfo entry just means /proc is not present.
else
	#  chroot
	typeset rootinum="$(\stat -c %i /)"
	if [ "$rootinum" -gt 1024 ]; then
		MYS_RUNENV="chroot"
	fi
fi



# -----------------------------------------------------------------------------
# Prompt
# -----------------------------------------------------------------------------

# Only show at startup
#if [[ -z "$MYS_LOADTIME" ]] && [[ -n "$PROMPT_COMMAND" ]]; then
#	echo >&2 "Warning: \$PROMPT_COMMAND is already set: '$PROMPT_COMMAND'"
#fi

typeset -i MYS_LOADTIME="$(date +%s)"
typeset -a MYS_PROMPTFUNCCB=()
function mys_promptfunc {
	typeset retcode=${1:-$?}

	# Call our post-exec hooks
	mys_postexec "$retcode"

	# Reload configuration if witness flag is present
	if [ -s "$MYSHELL_DIR/.reload" ]; then
		typeset time="$(cat $MYSHELL_DIR/.reload | tr -cd '[0-9]')"
		[ "${time:-0}" -gt "$MYS_LOADTIME" ] && mys_reload
		MYS_LOADTIME="$(date +%s)"
	fi

	typeset cb
	for cb in ${MYS_PROMPTFUNCCB[@]}; do
		[ -n "$cb" ] || continue
		$cb $retcode
	done

}

function mys_promptfunc_register {
	MYS_PROMPTFUNCCB+=("$*")
}


typeset -a MYS_PREEXECCB=() MYS_POSTEXECCB=()
typeset -i MYS_PREEXECTIME=0
typeset    MYS_PREEXECCMD=
function mys_preexec {
	# Skip our own PROMPT_COMMAND to reset our stats
	[ "${BASH_COMMAND%% *}" == "mys_promptfunc" ] && return

	typeset cb
	for cb in ${MYS_PREEXECCB[@]}; do
		[ -n "$cb" ] || continue
		$cb
	done
	MYS_PREEXECTIME="${SECONDS:-$(date +%s)}"
	MYS_PREEXECCMD+="${MYS_PREEXECCMD:+ | }$BASH_COMMAND"
	#echo "Preeec: $MYS_PREEXECCMD at $MYS_PREEXECTIME"
}
function mys_postexec {
	typeset retcode="$1"

	#echo "Postexec: took $((${SECONDS:-$(date +%s)} - $MYS_PREEXECTIME ))s for $MYS_PREEXECCMD"

	typeset cb
	for cb in ${MYS_PREEXECCB[@]}; do
		[ -n "$cb" ] || continue
		$cb "$retcode"
	done

	MYS_PREEXECCMD=""
}





# At the end, replace the PROMPT_COMMAND by our 
PROMPT_COMMAND='mys_promptfunc $?'
trap 'mys_preexec' DEBUG

# vim: ft=sh


# vim: ft=sh

# vim: ft=sh

function kubernetes::kubeconfigFind {
	typeset path="$1"

	typeset filename=
	# Loop every configured filename, or by default "kubeconfig"
	for filename in ${PRDVTY_KUBERNETES_CONFIG_NAMES:-kubeconfig}; do
		# Look for every path
		while [[ -n "$path" ]] && [[ -e "$path" ]]; do
			if [[ -s "$path/$filename" ]]; then
				echo "$path/$filename"
				return
			fi
			path="${path%/*}"
		done
	done

}

function kubernetes::kubectlFind {
	PATH+=":${PRDVTY_KUBERNETES_BIN_PATHS:-$HOME/bin}" type -p kubectl
}

function kubernetes::kubectl {

	typeset k="$(kubernetes::kubectlFind)"

	if ! [[ -n "$k" ]]; then
		echo >&2 "Unable to find kubectl (called for '$@')"
		return 1
	fi

	"$k" "$@"
}


typeset -gA __PRDVTY_KUBERNETES_CONFIG_PREV=()
function kubernetes::envSet {

	typeset path="$PWD"

	# Check if kubeconfig was set before, and 
	if [[ -n "$KUBECONFIG" ]]; then
		typeset kubeconfigPrev="${__PRDVTY_KUBERNETES_CONFIG_PREV[kubeconfig]}"
		# Check if the variable was not touched outside of us
		if [[ "$KUBECONFIG" != "$kubeconfigPrev" ]]; then
			logInfo "Variable '$KUBECONFIG' has been changed outside of $BASH_SOURCE::$FUNCNAME. Disabling autodiscovery"
			logInfo "To reenable autodiscovery, type 'unset KUBECONFIG'"
			return
		fi

		# No previous configuration
	fi

	# Do we have a kubeconfig file in our parent folders
	typeset config="$(kubernetes::kubeconfigFind "$path")"
	export KUBECONFIG="$config"
	__PRDVTY_KUBERNETES_CONFIG_PREV[kubeconfig]="$KUBECONFIG"

	# Set the cachedir to local tmp, in case of home in NFS
	typeset cache="/tmp/kubectl.cache.${USER:-$(whoami)}"
	mkdir -p "$cache"
	export KUBECACHEDIR="$cache"
	__PRDVTY_KUBERNETES_CONFIG_PREV[kubecachedir]="$KUBECACHEDIR"

}

function kubernetes::clusterInfo {
	
	typeset -a nodes=(kubernetes::kubectl get nodes)
	typeset -a namespaces=(kubernetes::kubectl get namespaces)
	
	typeset ns pod detail
	while read ns pod detail; do
		:
	done < <(kubernetes::kubectl get pods -A --output json)
}

function kubernetes::clusterStatus {
	:
}

function kubernetes::clusterNodes {
	kubernetes::kubectl get nodes --output json "$@" | jq '.items[].metadata | .name, .labels'  -c | paste - - | column -t
}

function kubernetes::clusterPods {
	kubernetes::kubectl get pods -A --output json "$@" | jq '.items[].metadata | .namespace, .name, .labels' -c | paste - - - | column -t
}

function kubernetes::clusterDebug {
	typeset dstDir="${1:-$PWD/kubernetes.debug.$(date +%Y-%m-%d_%H-%M-%S)}"

	echo "Will dump debug data in '$dstDir'."
	echo "Press any key to execute, or Ctrl+C to cancel..."
	read
	mkdir -p "$dstDir"

	typeset typ= kubectl="$(kubernetes::kubectlFind)"
	for typ in namespaces nodes pods persistentvolumes persistentvolumeclaims componentstatuses configmaps endpoints services deployments replicasets statefulsets applications appprojects cronjobs ingresses volumeattachments; do

		echo "Describing $typ..."
		kubectl describe $typ -A > "$dstDir/describe.$typ.txt"
	done

	echo "Dumping cluster-info..."
	kubernetes::kubectl cluster-info dump --output-directory="$dstDir/clusterinfo"

	echo "Done."
}


function kubernetes::envInit {

	# Search our kubectl command
	typeset kubectlPath="$(kubernetes::kubectlFind)"
	if [[ -x "$kubectlPath" ]]; then

		# Add kubectl to our path
		prdvty::envPathBinAdd "${kubectlPath%/*}"

		# Add completion
		source <($kubectlPath completion bash)

		# Add an alias, and bind its completion too
		alias k="kubectl"
		complete -F __start_kubectl k

		# Add k8s segment to powerline
		prdvty::powerlineSegmentAdd "k8s" "cmdtime"


		# Add our helpers. Commands like "klist" or "kdestroy" are kerberos...
		alias kubedebug="kubernetes::clusterDebug"
		alias kubestatus="kubernetes::clusterStatus"
		alias kubenodes="kubernetes::clusterNodes"
		alias kubepods="kubernetes::clusterPods"

		# Register our env func with prompt to check file at every path change
		prdvty::postexecfuncRegister "kubernetes::envSet"
	fi
}



# Init env
kubernetes::envInit


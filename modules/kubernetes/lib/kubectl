
function kubernetes::kubeconfigFind {
	typeset path="$1"

	typeset filename=
	# Loop every configured filename, or by default "kubeconfig"
	for filename in ${PRDVTY_KUBERNETES_CONFIG_NAMES:-kubeconfig}; do
		# Look for every path
		while [[ -n "$path" ]] && [[ -e "$path" ]]; do
			if [[ -s "$path/$filename" ]]; then
				echo "$path/$filename"
				return
			fi
			path="${path%/*}"
		done
	done

}

function kubernetes::kubectlFind {
	PATH+=":${PRDVTY_KUBERNETES_BIN_PATHS:-$HOME/bin}" type -p kubectl
}

typeset -gA __PRDVTY_KUBERNETES_CONFIG_PREV=()
#typeset -gi __PRDVTY_KUBERNETES_CONFIG_EDITTIME=0
function kubernetes::envSet {

	typeset path="$PWD"

	# Check if kubeconfig was set before, and 
	if [[ -n "$KUBECONFIG" ]]; then
		typeset kubeconfigPrev="${__PRDVTY_KUBERNETES_CONFIG_PREV[kubeconfig]}"
		# Check if the variable was not touched outside of us
		if [[ "$KUBECONFIG" != "$kubeconfigPrev" ]]; then
			logInfo "Variable '$KUBECONFIG' has been changed outside of $BASH_SOURCE::$FUNCNAME. Disabling autodiscovery"
			logInfo "To reenable autodiscovery, type 'kubernetes::envInit'"
			return
		fi

		# No previous configuration
	fi

	# Do we have a kubeconfig file in our parents
	typeset config="$(kubernetes::kubeconfigFind "$path")"
	export KUBECONFIG="$config"

	# Check for edit-time as cache
#	if [[ -s "$config" ]] && [[ 

	__PRDVTY_KUBERNETES_CONFIG_PREV[kubeconfig]="$KUBECONFIG"
}

function kubernetes::envInit {

	# Search our kubectl command
	typeset kubectlPath="$(kubernetes::kubectlFind)"
	if [[ -x "$kubectlPath" ]]; then

		# Add kubectl to our path
		prdvty::envPathBinAdd "${kubectlPath%/*}"

		# Add k8s segment to powerline
		prdvty::powerlineSegmentAdd "k8s" "cmdtime"
	fi

	# Register our env func with prompt to check file at every path change
	prdvty::postexecfuncRegister "kubernetes::envSet"

}


# Init env
kubernetes::envInit

# vim: ft=sh
